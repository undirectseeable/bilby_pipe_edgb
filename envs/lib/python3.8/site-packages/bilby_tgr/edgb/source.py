import lalsimulation
from bilby.gw.source import _base_lal_cbc_fd_waveform
from lal import CreateDict
import numpy as np

def edgb_waveform_generator(
    frequency_array, mass_1, mass_2, luminosity_distance,
    chi_1, chi_2, theta_jn, phase, alpha,
    **kwargs):
    waveform_kwargs = dict(
        waveform_approximant='IMRPhenomXAS', reference_frequency=20.0,
        minimum_frequency=20.0, maximum_frequency=1024.0,
        catch_waveform_errors=False, pn_spin_order=-1, pn_tidal_order=-1,
        pn_phase_order=-1, pn_amplitude_order=0)

    GR_waveform = _base_lal_cbc_fd_waveform(
        frequency_array=frequency_array, mass_1=mass_1, mass_2=mass_2,
        luminosity_distance=luminosity_distance, theta_jn=theta_jn, phase=phase,
        chi_1=chi_1, chi_2=chi_2, **waveform_kwargs)
        #a_1=a_1, a_2=a_2, tilt_1=tilt_1, tilt_2=tilt_2, phi_12=phi_12,
        #phi_jl=phi_jl, **waveform_kwargs)

    edgb_waveform = get_phase(GR_waveform, frequency_array, mass_1, mass_2, chi_1, chi_2, alpha)
    return edgb_waveform

def get_phase(waveform_hp, frequency_array, mass_1, mass_2,
    a_1, a_2, alpha):
    edgb_waveform = {}
    edgb_waveform['plus'] = waveform_hp['plus']
    edgb_waveform['cross'] = waveform_hp['cross']
    Mtot = mass_1 + mass_2
    transform_frequency = np.logical_and(frequency_array>=20.0, frequency_array<=1024.0)
    relative_velocity = np.power(frequency_array[transform_frequency] * np.pi * Mtot, 1/3.)
    s1EdGB = 2*(np.sqrt(1-a_1*a_1) - 1 + a_1*a_1) / a_1/ a_1
    s2EdGB = 2*(np.sqrt(1-a_2*a_2) - 1 + a_2*a_2) / a_2/ a_2
    eta = mass_1*mass_2 / Mtot**2
    coeff_m1 = -5*np.pi/448 * np.square(mass_1*mass_1*s2EdGB-mass_2*mass_2*s1EdGB)/np.power(eta, 5)/np.power(Mtot, 4)
    dphi = np.power(alpha, 4) * coeff_m1 * np.power(relative_velocity, -7)
    edgb_waveform['plus'][transform_frequency]  = np.abs(waveform_hp['plus'][transform_frequency])  * np.exp(1j * (np.angle(waveform_hp['plus'][transform_frequency]) + dphi))
    edgb_waveform['cross'][transform_frequency] = np.abs(waveform_hp['cross'][transform_frequency]) * np.exp(1j * (np.angle(waveform_hp['cross'][transform_frequency]) + dphi))
    return edgb_waveform
    
