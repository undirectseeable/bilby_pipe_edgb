# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _nds2
else:
    import _nds2

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _nds2.SWIG_PyInstanceMethod_New
_swig_new_static_method = _nds2.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _nds2.delete_SwigPyIterator
    value = _swig_new_instance_method(_nds2.SwigPyIterator_value)
    incr = _swig_new_instance_method(_nds2.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_nds2.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_nds2.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_nds2.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_nds2.SwigPyIterator_copy)
    next = _swig_new_instance_method(_nds2.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_nds2.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_nds2.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_nds2.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_nds2.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_nds2.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_nds2.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_nds2.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_nds2.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_nds2.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _nds2:
_nds2.SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _nds2.SHARED_PTR_DISOWN

class channel(object):
    r"""
    Represents a LIGO data channel
    A channel encasulates the meta data of LIGO data.  It has a name and parameters.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    CHANNEL_TYPE_UNKNOWN = _nds2.channel_CHANNEL_TYPE_UNKNOWN
    r"""
    Represents a LIGO data channel
    A channel encasulates the meta data of LIGO data.  It has a name and parameters.

    """
    CHANNEL_TYPE_ONLINE = _nds2.channel_CHANNEL_TYPE_ONLINE
    r"""
    Represents a LIGO data channel
    A channel encasulates the meta data of LIGO data.  It has a name and parameters.

    """
    CHANNEL_TYPE_RAW = _nds2.channel_CHANNEL_TYPE_RAW
    r"""
    Represents a LIGO data channel
    A channel encasulates the meta data of LIGO data.  It has a name and parameters.

    """
    CHANNEL_TYPE_RDS = _nds2.channel_CHANNEL_TYPE_RDS
    r"""
    Represents a LIGO data channel
    A channel encasulates the meta data of LIGO data.  It has a name and parameters.

    """
    CHANNEL_TYPE_STREND = _nds2.channel_CHANNEL_TYPE_STREND
    r"""
    Represents a LIGO data channel
    A channel encasulates the meta data of LIGO data.  It has a name and parameters.

    """
    CHANNEL_TYPE_MTREND = _nds2.channel_CHANNEL_TYPE_MTREND
    r"""
    Represents a LIGO data channel
    A channel encasulates the meta data of LIGO data.  It has a name and parameters.

    """
    CHANNEL_TYPE_TEST_POINT = _nds2.channel_CHANNEL_TYPE_TEST_POINT
    r"""
    Represents a LIGO data channel
    A channel encasulates the meta data of LIGO data.  It has a name and parameters.

    """
    CHANNEL_TYPE_STATIC = _nds2.channel_CHANNEL_TYPE_STATIC
    r"""
    Represents a LIGO data channel
    A channel encasulates the meta data of LIGO data.  It has a name and parameters.

    """
    DATA_TYPE_UNKNOWN = _nds2.channel_DATA_TYPE_UNKNOWN
    r"""
    Represents a LIGO data channel
    A channel encasulates the meta data of LIGO data.  It has a name and parameters.

    """
    DATA_TYPE_INT16 = _nds2.channel_DATA_TYPE_INT16
    r"""
    Represents a LIGO data channel
    A channel encasulates the meta data of LIGO data.  It has a name and parameters.

    """
    DATA_TYPE_INT32 = _nds2.channel_DATA_TYPE_INT32
    r"""
    Represents a LIGO data channel
    A channel encasulates the meta data of LIGO data.  It has a name and parameters.

    """
    DATA_TYPE_INT64 = _nds2.channel_DATA_TYPE_INT64
    r"""
    Represents a LIGO data channel
    A channel encasulates the meta data of LIGO data.  It has a name and parameters.

    """
    DATA_TYPE_FLOAT32 = _nds2.channel_DATA_TYPE_FLOAT32
    r"""
    Represents a LIGO data channel
    A channel encasulates the meta data of LIGO data.  It has a name and parameters.

    """
    DATA_TYPE_FLOAT64 = _nds2.channel_DATA_TYPE_FLOAT64
    r"""
    Represents a LIGO data channel
    A channel encasulates the meta data of LIGO data.  It has a name and parameters.

    """
    DATA_TYPE_COMPLEX32 = _nds2.channel_DATA_TYPE_COMPLEX32
    r"""
    Represents a LIGO data channel
    A channel encasulates the meta data of LIGO data.  It has a name and parameters.

    """
    DATA_TYPE_UINT32 = _nds2.channel_DATA_TYPE_UINT32
    r"""
    Represents a LIGO data channel
    A channel encasulates the meta data of LIGO data.  It has a name and parameters.

    """

    def __init__(self, Source: "channel"):
        r"""
        __init__(self, Source) -> channel

        Parameters
        ----------
        Source: channel const &

        Returns The name of the channel


        """
        _nds2.channel_swiginit(self, _nds2.new_channel(Source))
    Name = _swig_new_instance_method(_nds2.channel_Name)
    NameLong = _swig_new_instance_method(_nds2.channel_NameLong)
    Type = _swig_new_instance_method(_nds2.channel_Type)
    DataType = _swig_new_instance_method(_nds2.channel_DataType)
    DataTypeSize = _swig_new_instance_method(_nds2.channel_DataTypeSize)
    SampleRate = _swig_new_instance_method(_nds2.channel_SampleRate)
    Gain = _swig_new_instance_method(_nds2.channel_Gain)
    Slope = _swig_new_instance_method(_nds2.channel_Slope)
    Offset = _swig_new_instance_method(_nds2.channel_Offset)
    Units = _swig_new_instance_method(_nds2.channel_Units)
    IsSecondTrend = _swig_new_static_method(_nds2.channel_IsSecondTrend)
    IsMinuteTrend = _swig_new_static_method(_nds2.channel_IsMinuteTrend)
    channel_type_to_string = _swig_new_static_method(_nds2.channel_channel_type_to_string)
    data_type_to_string = _swig_new_static_method(_nds2.channel_data_type_to_string)
    __str__ = _swig_new_instance_method(_nds2.channel___str__)
    __repr__ = _swig_new_instance_method(_nds2.channel___repr__)

    try:
      __swig_getmethods__
    except NameError:
      __swig_getmethods__ = {}

    __swig_getmethods__['name'] = Name
    __swig_getmethods__['channel_type'] = Type
    __swig_getmethods__['data_type'] = DataType
    __swig_getmethods__['sample_rate'] = SampleRate
    #__swig_getmethods__['gain'] = Gain
    #__swig_getmethods__['slope'] = Slope
    #__swig_getmethods__['offset'] = Offset
    #__swig_getmethods__['units'] = Units
    __swig_getmethods__['signal_gain'] = Gain
    __swig_getmethods__['signal_slope'] = Slope
    __swig_getmethods__['signal_offset'] = Offset
    __swig_getmethods__['signal_units'] = Units

    try:
      object
      name = property(Name)
      channel_type = property(Type)
      data_type = property(DataType)
      sample_rate = property(SampleRate)
    #gain = property(Gain)
    #slope = property(Slope)
    #offset = property(Offset)
    #units = property(Units)
      signal_gain = property(Gain)
      signal_slope = property(Slope)
      signal_offset = property(Offset)
      signal_units = property(Units)
    except AttributeError:
      pass


    __swig_destroy__ = _nds2.delete_channel

# Register channel in _nds2:
_nds2.channel_swigregister(channel)
cvar = _nds2.cvar
channel.DEFAULT_CHANNEL_MASK = _nds2.cvar.channel_DEFAULT_CHANNEL_MASK
channel.DEFAULT_DATA_MASK = _nds2.cvar.channel_DEFAULT_DATA_MASK
channel.MIN_SAMPLE_RATE = _nds2.cvar.channel_MIN_SAMPLE_RATE
channel.MAX_SAMPLE_RATE = _nds2.cvar.channel_MAX_SAMPLE_RATE
channel_IsSecondTrend = _nds2.channel_IsSecondTrend
channel_IsMinuteTrend = _nds2.channel_IsMinuteTrend
channel_channel_type_to_string = _nds2.channel_channel_type_to_string
channel_data_type_to_string = _nds2.channel_data_type_to_string

class vectorChannels(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_nds2.vectorChannels_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_nds2.vectorChannels___nonzero__)
    __bool__ = _swig_new_instance_method(_nds2.vectorChannels___bool__)
    __len__ = _swig_new_instance_method(_nds2.vectorChannels___len__)
    __getslice__ = _swig_new_instance_method(_nds2.vectorChannels___getslice__)
    __setslice__ = _swig_new_instance_method(_nds2.vectorChannels___setslice__)
    __delslice__ = _swig_new_instance_method(_nds2.vectorChannels___delslice__)
    __delitem__ = _swig_new_instance_method(_nds2.vectorChannels___delitem__)
    __getitem__ = _swig_new_instance_method(_nds2.vectorChannels___getitem__)
    __setitem__ = _swig_new_instance_method(_nds2.vectorChannels___setitem__)
    pop = _swig_new_instance_method(_nds2.vectorChannels_pop)
    append = _swig_new_instance_method(_nds2.vectorChannels_append)
    empty = _swig_new_instance_method(_nds2.vectorChannels_empty)
    size = _swig_new_instance_method(_nds2.vectorChannels_size)
    swap = _swig_new_instance_method(_nds2.vectorChannels_swap)
    begin = _swig_new_instance_method(_nds2.vectorChannels_begin)
    end = _swig_new_instance_method(_nds2.vectorChannels_end)
    rbegin = _swig_new_instance_method(_nds2.vectorChannels_rbegin)
    rend = _swig_new_instance_method(_nds2.vectorChannels_rend)
    clear = _swig_new_instance_method(_nds2.vectorChannels_clear)
    get_allocator = _swig_new_instance_method(_nds2.vectorChannels_get_allocator)
    pop_back = _swig_new_instance_method(_nds2.vectorChannels_pop_back)
    erase = _swig_new_instance_method(_nds2.vectorChannels_erase)

    def __init__(self, *args):
        
        _nds2.vectorChannels_swiginit(self, _nds2.new_vectorChannels(*args))
    push_back = _swig_new_instance_method(_nds2.vectorChannels_push_back)
    front = _swig_new_instance_method(_nds2.vectorChannels_front)
    back = _swig_new_instance_method(_nds2.vectorChannels_back)
    assign = _swig_new_instance_method(_nds2.vectorChannels_assign)
    resize = _swig_new_instance_method(_nds2.vectorChannels_resize)
    insert = _swig_new_instance_method(_nds2.vectorChannels_insert)
    reserve = _swig_new_instance_method(_nds2.vectorChannels_reserve)
    capacity = _swig_new_instance_method(_nds2.vectorChannels_capacity)
    __swig_destroy__ = _nds2.delete_vectorChannels

# Register vectorChannels in _nds2:
_nds2.vectorChannels_swigregister(vectorChannels)

class channels_type(vectorChannels):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        
        _nds2.channels_type_swiginit(self, _nds2.new_channels_type())
    __swig_destroy__ = _nds2.delete_channels_type

# Register channels_type in _nds2:
_nds2.channels_type_swigregister(channels_type)

class channel_names_type(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_nds2.channel_names_type_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_nds2.channel_names_type___nonzero__)
    __bool__ = _swig_new_instance_method(_nds2.channel_names_type___bool__)
    __len__ = _swig_new_instance_method(_nds2.channel_names_type___len__)
    __getslice__ = _swig_new_instance_method(_nds2.channel_names_type___getslice__)
    __setslice__ = _swig_new_instance_method(_nds2.channel_names_type___setslice__)
    __delslice__ = _swig_new_instance_method(_nds2.channel_names_type___delslice__)
    __delitem__ = _swig_new_instance_method(_nds2.channel_names_type___delitem__)
    __getitem__ = _swig_new_instance_method(_nds2.channel_names_type___getitem__)
    __setitem__ = _swig_new_instance_method(_nds2.channel_names_type___setitem__)
    pop = _swig_new_instance_method(_nds2.channel_names_type_pop)
    append = _swig_new_instance_method(_nds2.channel_names_type_append)
    empty = _swig_new_instance_method(_nds2.channel_names_type_empty)
    size = _swig_new_instance_method(_nds2.channel_names_type_size)
    swap = _swig_new_instance_method(_nds2.channel_names_type_swap)
    begin = _swig_new_instance_method(_nds2.channel_names_type_begin)
    end = _swig_new_instance_method(_nds2.channel_names_type_end)
    rbegin = _swig_new_instance_method(_nds2.channel_names_type_rbegin)
    rend = _swig_new_instance_method(_nds2.channel_names_type_rend)
    clear = _swig_new_instance_method(_nds2.channel_names_type_clear)
    get_allocator = _swig_new_instance_method(_nds2.channel_names_type_get_allocator)
    pop_back = _swig_new_instance_method(_nds2.channel_names_type_pop_back)
    erase = _swig_new_instance_method(_nds2.channel_names_type_erase)

    def __init__(self, *args):
        
        _nds2.channel_names_type_swiginit(self, _nds2.new_channel_names_type(*args))
    push_back = _swig_new_instance_method(_nds2.channel_names_type_push_back)
    front = _swig_new_instance_method(_nds2.channel_names_type_front)
    back = _swig_new_instance_method(_nds2.channel_names_type_back)
    assign = _swig_new_instance_method(_nds2.channel_names_type_assign)
    resize = _swig_new_instance_method(_nds2.channel_names_type_resize)
    insert = _swig_new_instance_method(_nds2.channel_names_type_insert)
    reserve = _swig_new_instance_method(_nds2.channel_names_type_reserve)
    capacity = _swig_new_instance_method(_nds2.channel_names_type_capacity)
    __swig_destroy__ = _nds2.delete_channel_names_type

# Register channel_names_type in _nds2:
_nds2.channel_names_type_swigregister(channel_names_type)

class buffer(channel):
    r"""
    The buffer class facilitates the storage of data and accompanying meta data.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    GPS_INF = _nds2.buffer_GPS_INF
    r"""
    Check the channel name to see if it is a minute trend.
    Returns true if Name ends in 'm-trend' else false


    """
    Samples = _swig_new_instance_method(_nds2.buffer_Samples)
    Start = _swig_new_instance_method(_nds2.buffer_Start)
    StartNano = _swig_new_instance_method(_nds2.buffer_StartNano)
    Stop = _swig_new_instance_method(_nds2.buffer_Stop)
    ToString = _swig_new_instance_method(_nds2.buffer_ToString)
    Channel = _swig_new_instance_method(_nds2.buffer_Channel)
    data_pvt = _swig_new_instance_method(_nds2.buffer_data_pvt)

    def Data( self ):
      try:
        return self.pydata
      except AttributeError:
        self.pydata = self.data_pvt( )
      return self.pydata

    try:
      __swig_getmethods__
    except NameError:
      __swig_getmethods__ = {}

    __swig_getmethods__['channel'] = Channel
    __swig_getmethods__['data'] = Data
    __swig_getmethods__['gps_seconds'] = Start
    __swig_getmethods__['gps_nanoseconds'] = StartNano
    __swig_getmethods__['length'] = Samples

    try:
      object
      channel = property(Channel)
      data = property(Data)
      gps_seconds = property(Start)
      gps_nanoseconds = property(StartNano)
      length = property(Samples)
    except AttributeError:
      pass

    __str__ = _swig_new_instance_method(_nds2.buffer___str__)
    __repr__ = _swig_new_instance_method(_nds2.buffer___repr__)
    __swig_destroy__ = _nds2.delete_buffer

# Register buffer in _nds2:
_nds2.buffer_swigregister(buffer)

class vectorBuffers(object):
    r"""
    The buffer class facilitates the storage of data and accompanying meta data.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_nds2.vectorBuffers_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_nds2.vectorBuffers___nonzero__)
    __bool__ = _swig_new_instance_method(_nds2.vectorBuffers___bool__)
    __len__ = _swig_new_instance_method(_nds2.vectorBuffers___len__)
    __getslice__ = _swig_new_instance_method(_nds2.vectorBuffers___getslice__)
    __setslice__ = _swig_new_instance_method(_nds2.vectorBuffers___setslice__)
    __delslice__ = _swig_new_instance_method(_nds2.vectorBuffers___delslice__)
    __delitem__ = _swig_new_instance_method(_nds2.vectorBuffers___delitem__)
    __getitem__ = _swig_new_instance_method(_nds2.vectorBuffers___getitem__)
    __setitem__ = _swig_new_instance_method(_nds2.vectorBuffers___setitem__)
    pop = _swig_new_instance_method(_nds2.vectorBuffers_pop)
    append = _swig_new_instance_method(_nds2.vectorBuffers_append)
    empty = _swig_new_instance_method(_nds2.vectorBuffers_empty)
    size = _swig_new_instance_method(_nds2.vectorBuffers_size)
    swap = _swig_new_instance_method(_nds2.vectorBuffers_swap)
    begin = _swig_new_instance_method(_nds2.vectorBuffers_begin)
    end = _swig_new_instance_method(_nds2.vectorBuffers_end)
    rbegin = _swig_new_instance_method(_nds2.vectorBuffers_rbegin)
    rend = _swig_new_instance_method(_nds2.vectorBuffers_rend)
    clear = _swig_new_instance_method(_nds2.vectorBuffers_clear)
    get_allocator = _swig_new_instance_method(_nds2.vectorBuffers_get_allocator)
    pop_back = _swig_new_instance_method(_nds2.vectorBuffers_pop_back)
    erase = _swig_new_instance_method(_nds2.vectorBuffers_erase)

    def __init__(self, *args):
        r"""
        The buffer class facilitates the storage of data and accompanying meta data.

        """
        _nds2.vectorBuffers_swiginit(self, _nds2.new_vectorBuffers(*args))
    push_back = _swig_new_instance_method(_nds2.vectorBuffers_push_back)
    front = _swig_new_instance_method(_nds2.vectorBuffers_front)
    back = _swig_new_instance_method(_nds2.vectorBuffers_back)
    assign = _swig_new_instance_method(_nds2.vectorBuffers_assign)
    resize = _swig_new_instance_method(_nds2.vectorBuffers_resize)
    insert = _swig_new_instance_method(_nds2.vectorBuffers_insert)
    reserve = _swig_new_instance_method(_nds2.vectorBuffers_reserve)
    capacity = _swig_new_instance_method(_nds2.vectorBuffers_capacity)
    __swig_destroy__ = _nds2.delete_vectorBuffers

# Register vectorBuffers in _nds2:
_nds2.vectorBuffers_swigregister(vectorBuffers)

class buffers_type(vectorBuffers):
    r"""
    The buffer class facilitates the storage of data and accompanying meta data.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _nds2.delete_buffers_type
    ToString = _swig_new_instance_method(_nds2.buffers_type_ToString)

    def __init__(self):
        
        _nds2.buffers_type_swiginit(self, _nds2.new_buffers_type())

# Register buffers_type in _nds2:
_nds2.buffers_type_swigregister(buffers_type)

class vectorEpochs(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_nds2.vectorEpochs_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_nds2.vectorEpochs___nonzero__)
    __bool__ = _swig_new_instance_method(_nds2.vectorEpochs___bool__)
    __len__ = _swig_new_instance_method(_nds2.vectorEpochs___len__)
    __getslice__ = _swig_new_instance_method(_nds2.vectorEpochs___getslice__)
    __setslice__ = _swig_new_instance_method(_nds2.vectorEpochs___setslice__)
    __delslice__ = _swig_new_instance_method(_nds2.vectorEpochs___delslice__)
    __delitem__ = _swig_new_instance_method(_nds2.vectorEpochs___delitem__)
    __getitem__ = _swig_new_instance_method(_nds2.vectorEpochs___getitem__)
    __setitem__ = _swig_new_instance_method(_nds2.vectorEpochs___setitem__)
    pop = _swig_new_instance_method(_nds2.vectorEpochs_pop)
    append = _swig_new_instance_method(_nds2.vectorEpochs_append)
    empty = _swig_new_instance_method(_nds2.vectorEpochs_empty)
    size = _swig_new_instance_method(_nds2.vectorEpochs_size)
    swap = _swig_new_instance_method(_nds2.vectorEpochs_swap)
    begin = _swig_new_instance_method(_nds2.vectorEpochs_begin)
    end = _swig_new_instance_method(_nds2.vectorEpochs_end)
    rbegin = _swig_new_instance_method(_nds2.vectorEpochs_rbegin)
    rend = _swig_new_instance_method(_nds2.vectorEpochs_rend)
    clear = _swig_new_instance_method(_nds2.vectorEpochs_clear)
    get_allocator = _swig_new_instance_method(_nds2.vectorEpochs_get_allocator)
    pop_back = _swig_new_instance_method(_nds2.vectorEpochs_pop_back)
    erase = _swig_new_instance_method(_nds2.vectorEpochs_erase)

    def __init__(self, *args):
        
        _nds2.vectorEpochs_swiginit(self, _nds2.new_vectorEpochs(*args))
    push_back = _swig_new_instance_method(_nds2.vectorEpochs_push_back)
    front = _swig_new_instance_method(_nds2.vectorEpochs_front)
    back = _swig_new_instance_method(_nds2.vectorEpochs_back)
    assign = _swig_new_instance_method(_nds2.vectorEpochs_assign)
    resize = _swig_new_instance_method(_nds2.vectorEpochs_resize)
    insert = _swig_new_instance_method(_nds2.vectorEpochs_insert)
    reserve = _swig_new_instance_method(_nds2.vectorEpochs_reserve)
    capacity = _swig_new_instance_method(_nds2.vectorEpochs_capacity)
    __swig_destroy__ = _nds2.delete_vectorEpochs

# Register vectorEpochs in _nds2:
_nds2.vectorEpochs_swigregister(vectorEpochs)

class epoch(object):
    r"""
    A timespan, either named or explicity delimited
    An epoch is used to limit the scope of requests against an NDS2 server.The epoch may be named or have explicit [start, stop) ranges.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    name = property(_nds2.epoch_name_get, _nds2.epoch_name_set, doc=r"""
    A timespan, either named or explicity delimited
    An epoch is used to limit the scope of requests against an NDS2 server.The epoch may be named or have explicit [start, stop) ranges.

    """)
    gps_start = property(_nds2.epoch_gps_start_get, _nds2.epoch_gps_start_set, doc=r"""
    A timespan, either named or explicity delimited
    An epoch is used to limit the scope of requests against an NDS2 server.The epoch may be named or have explicit [start, stop) ranges.

    """)
    gps_stop = property(_nds2.epoch_gps_stop_get, _nds2.epoch_gps_stop_set, doc=r"""
    A timespan, either named or explicity delimited
    An epoch is used to limit the scope of requests against an NDS2 server.The epoch may be named or have explicit [start, stop) ranges.

    """)

    def __init__(self, *args):
        r"""
        A timespan, either named or explicity delimited
        An epoch is used to limit the scope of requests against an NDS2 server.The epoch may be named or have explicit [start, stop) ranges.

        """
        _nds2.epoch_swiginit(self, _nds2.new_epoch(*args))
    __str__ = _swig_new_instance_method(_nds2.epoch___str__)
    __repr__ = _swig_new_instance_method(_nds2.epoch___repr__)
    __swig_destroy__ = _nds2.delete_epoch

# Register epoch in _nds2:
_nds2.epoch_swigregister(epoch)

class epochs_type(vectorEpochs):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __str__ = _swig_new_instance_method(_nds2.epochs_type___str__)
    __repr__ = _swig_new_instance_method(_nds2.epochs_type___repr__)

    def __init__(self):
        
        _nds2.epochs_type_swiginit(self, _nds2.new_epochs_type())
    __swig_destroy__ = _nds2.delete_epochs_type

# Register epochs_type in _nds2:
_nds2.epochs_type_swigregister(epochs_type)

class segment(object):
    r"""
    An availability segment defines when data is available.
    LIGO data is not always avaialble.  Channels are added, removed,
    the data collection services or the instrument have downtime.  This
    structure holds information about a time span when data is available.
    An individual segment holds data on when a channel (not specified in the
    structure) was available in a  specific frame type in a given [start,stop) time frame.

    This information is only available for NDS2

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    frame_type = property(_nds2.segment_frame_type_get, _nds2.segment_frame_type_set, doc=r"""
    An availability segment defines when data is available.
    LIGO data is not always avaialble.  Channels are added, removed,
    the data collection services or the instrument have downtime.  This
    structure holds information about a time span when data is available.
    An individual segment holds data on when a channel (not specified in the
    structure) was available in a  specific frame type in a given [start,stop) time frame.

    This information is only available for NDS2

    """)
    gps_start = property(_nds2.segment_gps_start_get, _nds2.segment_gps_start_set, doc=r"""
    An availability segment defines when data is available.
    LIGO data is not always avaialble.  Channels are added, removed,
    the data collection services or the instrument have downtime.  This
    structure holds information about a time span when data is available.
    An individual segment holds data on when a channel (not specified in the
    structure) was available in a  specific frame type in a given [start,stop) time frame.

    This information is only available for NDS2

    """)
    gps_stop = property(_nds2.segment_gps_stop_get, _nds2.segment_gps_stop_set, doc=r"""
    An availability segment defines when data is available.
    LIGO data is not always avaialble.  Channels are added, removed,
    the data collection services or the instrument have downtime.  This
    structure holds information about a time span when data is available.
    An individual segment holds data on when a channel (not specified in the
    structure) was available in a  specific frame type in a given [start,stop) time frame.

    This information is only available for NDS2

    """)

    def __init__(self, *args):
        r"""
        An availability segment defines when data is available.
        LIGO data is not always avaialble.  Channels are added, removed,
        the data collection services or the instrument have downtime.  This
        structure holds information about a time span when data is available.
        An individual segment holds data on when a channel (not specified in the
        structure) was available in a  specific frame type in a given [start,stop) time frame.

        This information is only available for NDS2

        """
        _nds2.segment_swiginit(self, _nds2.new_segment(*args))
    __str__ = _swig_new_instance_method(_nds2.segment___str__)
    __repr__ = _swig_new_instance_method(_nds2.segment___repr__)
    __swig_destroy__ = _nds2.delete_segment

# Register segment in _nds2:
_nds2.segment_swigregister(segment)

class simple_segment(object):
    r"""
    A simple [start,stop) range for denoting segments

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __swig_destroy__ = _nds2.delete_simple_segment

    def __init__(self, *args):
        r"""
        A simple [start,stop) range for denoting segments

        """
        _nds2.simple_segment_swiginit(self, _nds2.new_simple_segment(*args))
    gps_start = property(_nds2.simple_segment_gps_start_get, _nds2.simple_segment_gps_start_set, doc=r"""
    A simple [start,stop) range for denoting segments

    """)
    gps_stop = property(_nds2.simple_segment_gps_stop_get, _nds2.simple_segment_gps_stop_set, doc=r"""
    A simple [start,stop) range for denoting segments

    """)
    __str__ = _swig_new_instance_method(_nds2.simple_segment___str__)
    __repr__ = _swig_new_instance_method(_nds2.simple_segment___repr__)

# Register simple_segment in _nds2:
_nds2.simple_segment_swigregister(simple_segment)

class vectorSimpleSegment(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_nds2.vectorSimpleSegment_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_nds2.vectorSimpleSegment___nonzero__)
    __bool__ = _swig_new_instance_method(_nds2.vectorSimpleSegment___bool__)
    __len__ = _swig_new_instance_method(_nds2.vectorSimpleSegment___len__)
    __getslice__ = _swig_new_instance_method(_nds2.vectorSimpleSegment___getslice__)
    __setslice__ = _swig_new_instance_method(_nds2.vectorSimpleSegment___setslice__)
    __delslice__ = _swig_new_instance_method(_nds2.vectorSimpleSegment___delslice__)
    __delitem__ = _swig_new_instance_method(_nds2.vectorSimpleSegment___delitem__)
    __getitem__ = _swig_new_instance_method(_nds2.vectorSimpleSegment___getitem__)
    __setitem__ = _swig_new_instance_method(_nds2.vectorSimpleSegment___setitem__)
    pop = _swig_new_instance_method(_nds2.vectorSimpleSegment_pop)
    append = _swig_new_instance_method(_nds2.vectorSimpleSegment_append)
    empty = _swig_new_instance_method(_nds2.vectorSimpleSegment_empty)
    size = _swig_new_instance_method(_nds2.vectorSimpleSegment_size)
    swap = _swig_new_instance_method(_nds2.vectorSimpleSegment_swap)
    begin = _swig_new_instance_method(_nds2.vectorSimpleSegment_begin)
    end = _swig_new_instance_method(_nds2.vectorSimpleSegment_end)
    rbegin = _swig_new_instance_method(_nds2.vectorSimpleSegment_rbegin)
    rend = _swig_new_instance_method(_nds2.vectorSimpleSegment_rend)
    clear = _swig_new_instance_method(_nds2.vectorSimpleSegment_clear)
    get_allocator = _swig_new_instance_method(_nds2.vectorSimpleSegment_get_allocator)
    pop_back = _swig_new_instance_method(_nds2.vectorSimpleSegment_pop_back)
    erase = _swig_new_instance_method(_nds2.vectorSimpleSegment_erase)

    def __init__(self, *args):
        
        _nds2.vectorSimpleSegment_swiginit(self, _nds2.new_vectorSimpleSegment(*args))
    push_back = _swig_new_instance_method(_nds2.vectorSimpleSegment_push_back)
    front = _swig_new_instance_method(_nds2.vectorSimpleSegment_front)
    back = _swig_new_instance_method(_nds2.vectorSimpleSegment_back)
    assign = _swig_new_instance_method(_nds2.vectorSimpleSegment_assign)
    resize = _swig_new_instance_method(_nds2.vectorSimpleSegment_resize)
    insert = _swig_new_instance_method(_nds2.vectorSimpleSegment_insert)
    reserve = _swig_new_instance_method(_nds2.vectorSimpleSegment_reserve)
    capacity = _swig_new_instance_method(_nds2.vectorSimpleSegment_capacity)
    __swig_destroy__ = _nds2.delete_vectorSimpleSegment

# Register vectorSimpleSegment in _nds2:
_nds2.vectorSimpleSegment_swigregister(vectorSimpleSegment)

class simple_segment_list_type(vectorSimpleSegment):
    r"""
    A list of simple_segment objects.  This does not contain the channel name.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __str__ = _swig_new_instance_method(_nds2.simple_segment_list_type___str__)
    __repr__ = _swig_new_instance_method(_nds2.simple_segment_list_type___repr__)

    def __init__(self):
        
        _nds2.simple_segment_list_type_swiginit(self, _nds2.new_simple_segment_list_type())
    __swig_destroy__ = _nds2.delete_simple_segment_list_type

# Register simple_segment_list_type in _nds2:
_nds2.simple_segment_list_type_swigregister(simple_segment_list_type)

class vectorSimpleSegmentListType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType___nonzero__)
    __bool__ = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType___bool__)
    __len__ = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType___len__)
    __getslice__ = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType___getslice__)
    __setslice__ = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType___setslice__)
    __delslice__ = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType___delslice__)
    __delitem__ = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType___delitem__)
    __getitem__ = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType___getitem__)
    __setitem__ = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType___setitem__)
    pop = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_pop)
    append = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_append)
    empty = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_empty)
    size = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_size)
    swap = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_swap)
    begin = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_begin)
    end = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_end)
    rbegin = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_rbegin)
    rend = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_rend)
    clear = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_clear)
    get_allocator = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_get_allocator)
    pop_back = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_pop_back)
    erase = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_erase)

    def __init__(self, *args):
        
        _nds2.vectorSimpleSegmentListType_swiginit(self, _nds2.new_vectorSimpleSegmentListType(*args))
    push_back = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_push_back)
    front = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_front)
    back = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_back)
    assign = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_assign)
    resize = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_resize)
    insert = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_insert)
    reserve = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_reserve)
    capacity = _swig_new_instance_method(_nds2.vectorSimpleSegmentListType_capacity)
    __swig_destroy__ = _nds2.delete_vectorSimpleSegmentListType

# Register vectorSimpleSegmentListType in _nds2:
_nds2.vectorSimpleSegmentListType_swigregister(vectorSimpleSegmentListType)

class simple_availability_list_type(vectorSimpleSegmentListType):
    r"""
    A list of lists containing simple_segment objects

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    ToString = _swig_new_instance_method(_nds2.simple_availability_list_type_ToString)
    __str__ = _swig_new_instance_method(_nds2.simple_availability_list_type___str__)
    __repr__ = _swig_new_instance_method(_nds2.simple_availability_list_type___repr__)

    def __init__(self):
        
        _nds2.simple_availability_list_type_swiginit(self, _nds2.new_simple_availability_list_type())
    __swig_destroy__ = _nds2.delete_simple_availability_list_type

# Register simple_availability_list_type in _nds2:
_nds2.simple_availability_list_type_swigregister(simple_availability_list_type)

class vectorSegment(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_nds2.vectorSegment_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_nds2.vectorSegment___nonzero__)
    __bool__ = _swig_new_instance_method(_nds2.vectorSegment___bool__)
    __len__ = _swig_new_instance_method(_nds2.vectorSegment___len__)
    __getslice__ = _swig_new_instance_method(_nds2.vectorSegment___getslice__)
    __setslice__ = _swig_new_instance_method(_nds2.vectorSegment___setslice__)
    __delslice__ = _swig_new_instance_method(_nds2.vectorSegment___delslice__)
    __delitem__ = _swig_new_instance_method(_nds2.vectorSegment___delitem__)
    __getitem__ = _swig_new_instance_method(_nds2.vectorSegment___getitem__)
    __setitem__ = _swig_new_instance_method(_nds2.vectorSegment___setitem__)
    pop = _swig_new_instance_method(_nds2.vectorSegment_pop)
    append = _swig_new_instance_method(_nds2.vectorSegment_append)
    empty = _swig_new_instance_method(_nds2.vectorSegment_empty)
    size = _swig_new_instance_method(_nds2.vectorSegment_size)
    swap = _swig_new_instance_method(_nds2.vectorSegment_swap)
    begin = _swig_new_instance_method(_nds2.vectorSegment_begin)
    end = _swig_new_instance_method(_nds2.vectorSegment_end)
    rbegin = _swig_new_instance_method(_nds2.vectorSegment_rbegin)
    rend = _swig_new_instance_method(_nds2.vectorSegment_rend)
    clear = _swig_new_instance_method(_nds2.vectorSegment_clear)
    get_allocator = _swig_new_instance_method(_nds2.vectorSegment_get_allocator)
    pop_back = _swig_new_instance_method(_nds2.vectorSegment_pop_back)
    erase = _swig_new_instance_method(_nds2.vectorSegment_erase)

    def __init__(self, *args):
        
        _nds2.vectorSegment_swiginit(self, _nds2.new_vectorSegment(*args))
    push_back = _swig_new_instance_method(_nds2.vectorSegment_push_back)
    front = _swig_new_instance_method(_nds2.vectorSegment_front)
    back = _swig_new_instance_method(_nds2.vectorSegment_back)
    assign = _swig_new_instance_method(_nds2.vectorSegment_assign)
    resize = _swig_new_instance_method(_nds2.vectorSegment_resize)
    insert = _swig_new_instance_method(_nds2.vectorSegment_insert)
    reserve = _swig_new_instance_method(_nds2.vectorSegment_reserve)
    capacity = _swig_new_instance_method(_nds2.vectorSegment_capacity)
    __swig_destroy__ = _nds2.delete_vectorSegment

# Register vectorSegment in _nds2:
_nds2.vectorSegment_swigregister(vectorSegment)

class segment_list_type(vectorSegment):
    r"""
    A list of detailed segments.  This does not contain the channel name.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __str__ = _swig_new_instance_method(_nds2.segment_list_type___str__)
    __repr__ = _swig_new_instance_method(_nds2.segment_list_type___repr__)

    def __init__(self):
        
        _nds2.segment_list_type_swiginit(self, _nds2.new_segment_list_type())
    __swig_destroy__ = _nds2.delete_segment_list_type

# Register segment_list_type in _nds2:
_nds2.segment_list_type_swigregister(segment_list_type)

class availability(object):
    r"""
    Availability information for a single channel.
    This contains a channel name, and a list of segments in which
    the data is available.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    name = property(_nds2.availability_name_get, _nds2.availability_name_set, doc=r"""
    Availability information for a single channel.
    This contains a channel name, and a list of segments in which
    the data is available.

    """)
    data = property(_nds2.availability_data_get, _nds2.availability_data_set, doc=r"""
    Availability information for a single channel.
    This contains a channel name, and a list of segments in which
    the data is available.

    """)
    simple_list = _swig_new_instance_method(_nds2.availability_simple_list)
    ToString = _swig_new_instance_method(_nds2.availability_ToString)
    __str__ = _swig_new_instance_method(_nds2.availability___str__)
    __repr__ = _swig_new_instance_method(_nds2.availability___repr__)

    def __init__(self):
        
        _nds2.availability_swiginit(self, _nds2.new_availability())
    __swig_destroy__ = _nds2.delete_availability

# Register availability in _nds2:
_nds2.availability_swigregister(availability)

class availabilityListType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_nds2.availabilityListType_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_nds2.availabilityListType___nonzero__)
    __bool__ = _swig_new_instance_method(_nds2.availabilityListType___bool__)
    __len__ = _swig_new_instance_method(_nds2.availabilityListType___len__)
    __getslice__ = _swig_new_instance_method(_nds2.availabilityListType___getslice__)
    __setslice__ = _swig_new_instance_method(_nds2.availabilityListType___setslice__)
    __delslice__ = _swig_new_instance_method(_nds2.availabilityListType___delslice__)
    __delitem__ = _swig_new_instance_method(_nds2.availabilityListType___delitem__)
    __getitem__ = _swig_new_instance_method(_nds2.availabilityListType___getitem__)
    __setitem__ = _swig_new_instance_method(_nds2.availabilityListType___setitem__)
    pop = _swig_new_instance_method(_nds2.availabilityListType_pop)
    append = _swig_new_instance_method(_nds2.availabilityListType_append)
    empty = _swig_new_instance_method(_nds2.availabilityListType_empty)
    size = _swig_new_instance_method(_nds2.availabilityListType_size)
    swap = _swig_new_instance_method(_nds2.availabilityListType_swap)
    begin = _swig_new_instance_method(_nds2.availabilityListType_begin)
    end = _swig_new_instance_method(_nds2.availabilityListType_end)
    rbegin = _swig_new_instance_method(_nds2.availabilityListType_rbegin)
    rend = _swig_new_instance_method(_nds2.availabilityListType_rend)
    clear = _swig_new_instance_method(_nds2.availabilityListType_clear)
    get_allocator = _swig_new_instance_method(_nds2.availabilityListType_get_allocator)
    pop_back = _swig_new_instance_method(_nds2.availabilityListType_pop_back)
    erase = _swig_new_instance_method(_nds2.availabilityListType_erase)

    def __init__(self, *args):
        
        _nds2.availabilityListType_swiginit(self, _nds2.new_availabilityListType(*args))
    push_back = _swig_new_instance_method(_nds2.availabilityListType_push_back)
    front = _swig_new_instance_method(_nds2.availabilityListType_front)
    back = _swig_new_instance_method(_nds2.availabilityListType_back)
    assign = _swig_new_instance_method(_nds2.availabilityListType_assign)
    resize = _swig_new_instance_method(_nds2.availabilityListType_resize)
    insert = _swig_new_instance_method(_nds2.availabilityListType_insert)
    reserve = _swig_new_instance_method(_nds2.availabilityListType_reserve)
    capacity = _swig_new_instance_method(_nds2.availabilityListType_capacity)
    __swig_destroy__ = _nds2.delete_availabilityListType

# Register availabilityListType in _nds2:
_nds2.availabilityListType_swigregister(availabilityListType)

class availability_list_type(availabilityListType):
    r"""
    A list of availabilities (channels, availablity segments)
    This contians a list of detailed availaiblity lists for several channels

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __swig_destroy__ = _nds2.delete_availability_list_type
    simple_list = _swig_new_instance_method(_nds2.availability_list_type_simple_list)
    ToString = _swig_new_instance_method(_nds2.availability_list_type_ToString)
    __str__ = _swig_new_instance_method(_nds2.availability_list_type___str__)
    __repr__ = _swig_new_instance_method(_nds2.availability_list_type___repr__)

    def __init__(self):
        
        _nds2.availability_list_type_swiginit(self, _nds2.new_availability_list_type())

# Register availability_list_type in _nds2:
_nds2.availability_list_type_swigregister(availability_list_type)

class connection(object):
    r"""
    A connection to the NDS/NDS2 server
    The connection object is used to interact with the NDS (v1 or v2) servers to retrieve
           data and channel lists.
     Connnection objects have a few main categories of methods:
           1. Data retreival (fetch and iterate)
           2. Channel listing (find_channels)

           In addition there are methods designed to deal with the volume of data and channels in a NDS2 server:
           1. Setting limits/epochs on requests (get_epoch, set_epoch, current_epoch)
           2. Channel availability checking (get_availability)

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    PROTOCOL_INVALID = _nds2.connection_PROTOCOL_INVALID
    r"""
    A connection to the NDS/NDS2 server
    The connection object is used to interact with the NDS (v1 or v2) servers to retrieve
           data and channel lists.
     Connnection objects have a few main categories of methods:
           1. Data retreival (fetch and iterate)
           2. Channel listing (find_channels)

           In addition there are methods designed to deal with the volume of data and channels in a NDS2 server:
           1. Setting limits/epochs on requests (get_epoch, set_epoch, current_epoch)
           2. Channel availability checking (get_availability)

    """
    PROTOCOL_ONE = _nds2.connection_PROTOCOL_ONE
    r"""
    A connection to the NDS/NDS2 server
    The connection object is used to interact with the NDS (v1 or v2) servers to retrieve
           data and channel lists.
     Connnection objects have a few main categories of methods:
           1. Data retreival (fetch and iterate)
           2. Channel listing (find_channels)

           In addition there are methods designed to deal with the volume of data and channels in a NDS2 server:
           1. Setting limits/epochs on requests (get_epoch, set_epoch, current_epoch)
           2. Channel availability checking (get_availability)

    """
    PROTOCOL_TWO = _nds2.connection_PROTOCOL_TWO
    r"""
    A connection to the NDS/NDS2 server
    The connection object is used to interact with the NDS (v1 or v2) servers to retrieve
           data and channel lists.
     Connnection objects have a few main categories of methods:
           1. Data retreival (fetch and iterate)
           2. Channel listing (find_channels)

           In addition there are methods designed to deal with the volume of data and channels in a NDS2 server:
           1. Setting limits/epochs on requests (get_epoch, set_epoch, current_epoch)
           2. Channel availability checking (get_availability)

    """
    PROTOCOL_TRY = _nds2.connection_PROTOCOL_TRY
    r"""
    A connection to the NDS/NDS2 server
    The connection object is used to interact with the NDS (v1 or v2) servers to retrieve
           data and channel lists.
     Connnection objects have a few main categories of methods:
           1. Data retreival (fetch and iterate)
           2. Channel listing (find_channels)

           In addition there are methods designed to deal with the volume of data and channels in a NDS2 server:
           1. Setting limits/epochs on requests (get_epoch, set_epoch, current_epoch)
           2. Channel availability checking (get_availability)

    """
    DEFAULT_PORT = _nds2.connection_DEFAULT_PORT
    r"""
    A connection to the NDS/NDS2 server
    The connection object is used to interact with the NDS (v1 or v2) servers to retrieve
           data and channel lists.
     Connnection objects have a few main categories of methods:
           1. Data retreival (fetch and iterate)
           2. Channel listing (find_channels)

           In addition there are methods designed to deal with the volume of data and channels in a NDS2 server:
           1. Setting limits/epochs on requests (get_epoch, set_epoch, current_epoch)
           2. Channel availability checking (get_availability)

    """
    FAST_STRIDE = _nds2.connection_FAST_STRIDE
    r"""
    A connection to the NDS/NDS2 server
    The connection object is used to interact with the NDS (v1 or v2) servers to retrieve
           data and channel lists.
     Connnection objects have a few main categories of methods:
           1. Data retreival (fetch and iterate)
           2. Channel listing (find_channels)

           In addition there are methods designed to deal with the volume of data and channels in a NDS2 server:
           1. Setting limits/epochs on requests (get_epoch, set_epoch, current_epoch)
           2. Channel availability checking (get_availability)

    """
    AUTO_STRIDE = _nds2.connection_AUTO_STRIDE
    r"""
    A connection to the NDS/NDS2 server
    The connection object is used to interact with the NDS (v1 or v2) servers to retrieve
           data and channel lists.
     Connnection objects have a few main categories of methods:
           1. Data retreival (fetch and iterate)
           2. Channel listing (find_channels)

           In addition there are methods designed to deal with the volume of data and channels in a NDS2 server:
           1. Setting limits/epochs on requests (get_epoch, set_epoch, current_epoch)
           2. Channel availability checking (get_availability)

    """

    def __init__(self, *args):
        r"""
        __init__(self, host, port=DEFAULT_PORT, protocol=PROTOCOL_TRY) -> connection

        Parameters
        ----------
        host -- string -- Server to connect to
        port -- int -- Port number to connect to (defaults to DEFAULT_PORT)
        protocol -- protocol -- Protocol version to use (defaults to PROTOCOL_TRY)

        __init__(self, params) -> connection

        Parameters
        ----------
        params: parameters const &

        __init__(self) -> connection
        Create a connection with settings extracted from the environment

        """

        args = _hack_for_python2_strings(args)


        _nds2.connection_swiginit(self, _nds2.new_connection(*args))
    __swig_destroy__ = _nds2.delete_connection
    close = _swig_new_instance_method(_nds2.connection_close)

    def count_channels(self, *args) -> "connection::count_type":
        r"""
        count_channels(self, channel_glob="*", channel_type_mask=DEFAULT_CHANNEL_MASK, data_type_mask=DEFAULT_DATA_MASK, min_sample_rate=MIN_SAMPLE_RATE, max_sample_rate=MAX_SAMPLE_RATE) -> connection::count_type

        Parameters
        ----------
        channel_glob -- string -- A string to match channels to.  Bash style globs are allowed (* to mach anything, ? matches 1 character).  '*' matches all channels.
        channel_type_mask -- string -- Set of channel types to search.  Defaults to all.
        data_type_mask -- string -- A set of data types to search.  Defaults to all.
        min_sample_rate -- float -- The lowest sample rate to return.
        max_sample_rate -- float -- The highest sample rate to return.

        Returns A count of channels matching the input parameters.

        REMARK: For NDS1 a local cache of the channel list is searched.  For NDS2 this call may result in one or requests to the server, no local cache is used.
        REMARK: For requests against an NDS2 server the count is further constrained by the channels availabe during the currently selected epoch.

        """

        args = _hack_for_python2_strings(args)


        return _nds2.connection_count_channels(self, *args)


    def find_channels(self, *args) -> "channels_type":
        r"""
        find_channels(self, channel_glob="*", channel_type_mask=DEFAULT_CHANNEL_MASK, data_type_mask=DEFAULT_DATA_MASK, min_sample_rate=MIN_SAMPLE_RATE, max_sample_rate=MAX_SAMPLE_RATE) -> channels_type

        Parameters
        ----------
        channel_glob -- string -- A string to match channels to.  Bash style globs are allowed (* to mach anything, ? matches 1 character).  '*' matches all channels.
        channel_type_mask -- string -- Set of channel types to search.  Defaults to all.
        data_type_mask -- string -- A set of data types to search.  Defaults to all.
        min_sample_rate -- float -- The lowest sample rate to return.
        max_sample_rate -- float -- The highest sample rate to return.

        Returns A list of available channels matching the input parameters.

        REMARK: For NDS1 a local cache of the channel list is searched.  For NDS2 this call may result in one or requests to the server, no local cache is used.
        REMARK: For requests against an NDS2 server the count is further constrained by the channels availabe during the currently selected epoch.

        """

        args = _hack_for_python2_strings(args)


        return _nds2.connection_find_channels(self, *args)

    get_epochs = _swig_new_instance_method(_nds2.connection_get_epochs)

    def set_epoch(self, *args) -> "bool":
        r"""
        set_epoch(self, epoch) -> bool

        Parameters
        ----------
        epoch -- string -- The epoch value as a string

        set_epoch(self, gps_start, gps_stop) -> bool

        Parameters
        ----------
        gps_start -- long -- Start GPS Time
        gps_stop -- long -- Stop GPS Time

        """

        args = _hack_for_python2_strings(args)


        return _nds2.connection_set_epoch(self, *args)

    current_epoch = _swig_new_instance_method(_nds2.connection_current_epoch)

    def check(self, gps_start: "buffer::gps_second_type", gps_stop: "buffer::gps_second_type", channel_names: "channel_names_type") -> "bool":
        r"""
        check(self, gps_start, gps_stop, channel_names) -> bool

        Parameters
        ----------
        gps_start -- long -- Start GPS Time
        gps_stop -- long -- Stop GPS Time
        channel_names: connection::channel_names_type const &

        Check to see if data is avaiable
        Given a start/stop time and a channel list check to see if a fetch request would suceed.  This will return failure if there is a gap in the data, or if the data is on tape.
        Returns True if the data is available and not on tape.


        """

        if 'args' in dir():
            args = _hack_for_python2_strings(args)
        else:
            channel_names = _hack_for_python2_strings(channel_names)


        return _nds2.connection_check(self, gps_start, gps_stop, channel_names)


    def fetch(self, gps_start: "buffer::gps_second_type", gps_stop: "buffer::gps_second_type", channel_names: "channel_names_type") -> "buffers_type":
        r"""
        fetch(self, gps_start, gps_stop, channel_names) -> buffers_type

        Parameters
        ----------
        gps_start -- long -- Start GPS Time
        gps_stop -- long -- Stop GPS Time
        channel_names: connection::channel_names_type const &

        Retreive data from the server
        Given a start/stop time and a channel list retreive the associated data.
        Returns A list of buffers containing the request data.

        REMARK: This command can respond to missing data and high latency situations in various ways.  Use the (get/set)_parameter function to set how data gaps or data on tape situations are handled.

        """

        if 'args' in dir():
            args = _hack_for_python2_strings(args)
        else:
            channel_names = _hack_for_python2_strings(channel_names)


        return _nds2.connection_fetch(self, gps_start, gps_stop, channel_names)

    get_host = _swig_new_instance_method(_nds2.connection_get_host)
    get_port = _swig_new_instance_method(_nds2.connection_get_port)
    get_protocol = _swig_new_instance_method(_nds2.connection_get_protocol)

    def set_parameter(self, parameter: "std::string const &", value: "std::string const &") -> "bool":
        r"""
        set_parameter(self, parameter, value) -> bool

        Parameters
        ----------
        parameter: std::string const &
        value: std::string const &

        Change the default behavior of the connection.
        The connection object has a series of parameters that can be set.  Currently the parameters that can be set are "ALLOW_DATA_ON_TAPE", "GAP_HANDLER", and "ITERATE_USE_GAP_HANDLERS"
        REMARK: ALLOW_DATA_ON_TAPE (NDS2 only).  The NDS2 server may serve data that resides on a high latency storage layer, such as a tape system.  This may lead to data requests taking minutes or hours to complete, depending on the load on the storage system.  As of version 0.12 of the client the default is to raise an error when accessing data that is on a high latency storage layer.  This allows the application to provide feedback (if needed) to a users regarding amount of time that a request may take.  If this parameter is set to a true value ("True", "1", "yes") then an error will not be raised when requesting data on a high latency storage.
        REMARK: GAP_HANDLER For a given request there may not be be data available to fill the request completely.  This happens due to issues upstream of the NDS server.  How this is handled is application specific.  Setting the "GAP_HANDLER" parameter allows the application to specify what to do.  This includes options such as abort, zero fill the data, ...
        REMARK: ITERATE_USE_GAP_HANDLERS The iterate methods have a special case.  Unlike fetch operations which work on a single block, the iterate methods retrieve chunks of data that may not need to be contigous.  Setting ITERATE_USE_GAP_HANDLERS to "false" configures the connection to simply skip any gaps in the data and only return the data that is available.
        REMARK: Please note that if you are asking for multiple channels that do not have identical gaps the NDS servers will return a data not found error if ITERATE_USE_GAP_HANDLERS is set to false.
        Returns True if the value could be set, else false


        """

        if 'args' in dir():
            args = _hack_for_python2_strings(args)
        else:
            parameter, value = _hack_for_python2_strings((parameter, value))


        return _nds2.connection_set_parameter(self, parameter, value)


    def get_parameter(self, parameter: "std::string const &") -> "std::string":
        r"""
        get_parameter(self, parameter) -> std::string

        Parameters
        ----------
        parameter: std::string const &

        Retreive the current parameter setting on a connection.
        REMARK: See documentation for set_parameter for details on the parameters.
        Returns The parameter value, or the empty string if an invalid parameter is requested


        """

        if 'args' in dir():
            args = _hack_for_python2_strings(args)
        else:
            parameter = _hack_for_python2_strings((parameter,))[0]


        return _nds2.connection_get_parameter(self, parameter)

    get_parameters = _swig_new_instance_method(_nds2.connection_get_parameters)
    parameters = _swig_new_instance_method(_nds2.connection_parameters)
    hash = _swig_new_instance_method(_nds2.connection_hash)

    def iterate(self, *args) -> "connection &":
        r"""
        iterate(self, gps_start, gps_stop, stride, channel_names) -> connection

        Parameters
        ----------
        gps_start -- long -- The start time of the request.
        gps_stop -- long -- The end time of the request [gps_start, gps_stop).
        stride -- long -- The number of seconds of data to return in each chunk.
        channel_names: connection::channel_names_type const &

        iterate(self, channel_names) -> connection

        Parameters
        ----------
        channel_names: connection::channel_names_type const &

        iterate(self, stride, channel_names) -> connection

        Parameters
        ----------
        stride -- long -- The number of seconds of data to return in each chunk.
        channel_names: connection::channel_names_type const &

        iterate(self, gps_start, gps_stop, channel_names) -> connection

        Parameters
        ----------
        gps_start -- long -- The start time of the request.
        gps_stop -- long -- The end time of the request [gps_start, gps_stop).
        channel_names: connection::channel_names_type const &

        """

        args = _hack_for_python2_strings(args)


        return _nds2.connection_iterate(self, *args)

    next = _swig_new_instance_method(_nds2.connection_next)
    request_in_progress = _swig_new_instance_method(_nds2.connection_request_in_progress)
    shutdown = _swig_new_instance_method(_nds2.connection_shutdown)

    def get_availability(self, channel_names: "channel_names_type") -> "availability_list_type":
        r"""
        get_availability(self, channel_names) -> availability_list_type

        Parameters
        ----------
        channel_names: connection::channel_names_type const &

        Returns True if there is another data segment available during an iteration.


        """

        if 'args' in dir():
            args = _hack_for_python2_strings(args)
        else:
            channel_names = _hack_for_python2_strings(channel_names)


        return _nds2.connection_get_availability(self, channel_names)


    def __iter__(self):
      return self

    def __next__(self):
      return self.next()

    __str__ = _swig_new_instance_method(_nds2.connection___str__)
    __repr__ = _swig_new_instance_method(_nds2.connection___repr__)

# Register connection in _nds2:
_nds2.connection_swigregister(connection)

class channel_predicate(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        
        _nds2.channel_predicate_swiginit(self, _nds2.new_channel_predicate(*args))
    glob = _swig_new_instance_method(_nds2.channel_predicate_glob)
    channel_type_mask = _swig_new_instance_method(_nds2.channel_predicate_channel_type_mask)
    data_type_mask = _swig_new_instance_method(_nds2.channel_predicate_data_type_mask)
    min_sample_rate = _swig_new_instance_method(_nds2.channel_predicate_min_sample_rate)
    max_sample_rate = _swig_new_instance_method(_nds2.channel_predicate_max_sample_rate)
    gps_start = _swig_new_instance_method(_nds2.channel_predicate_gps_start)
    gps_stop = _swig_new_instance_method(_nds2.channel_predicate_gps_stop)
    set_glob = _swig_new_instance_method(_nds2.channel_predicate_set_glob)
    set_channel_type_mask = _swig_new_instance_method(_nds2.channel_predicate_set_channel_type_mask)
    set_data_type_mask = _swig_new_instance_method(_nds2.channel_predicate_set_data_type_mask)
    set_frequency_range = _swig_new_instance_method(_nds2.channel_predicate_set_frequency_range)
    set_timespan = _swig_new_instance_method(_nds2.channel_predicate_set_timespan)
    __swig_destroy__ = _nds2.delete_channel_predicate

# Register channel_predicate in _nds2:
_nds2.channel_predicate_swigregister(channel_predicate)

class request_period(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        
        _nds2.request_period_swiginit(self, _nds2.new_request_period(*args))
    start = property(_nds2.request_period_start_get, _nds2.request_period_start_set, doc=r"""start""")
    stop = property(_nds2.request_period_stop_get, _nds2.request_period_stop_set, doc=r"""stop""")
    stride = property(_nds2.request_period_stride_get, _nds2.request_period_stride_set, doc=r"""stride""")
    __swig_destroy__ = _nds2.delete_request_period

# Register request_period in _nds2:
_nds2.request_period_swigregister(request_period)

class parameters(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> parameters
        __init__(self, hostname, arg3=DEFAULT_PORT, arg4=connection::DEFAULT_PROTOCOL) -> parameters

        Parameters
        ----------
        hostname: connection::host_type
        arg3: connection::port_type
        arg4 -- protocol -- Protocol version to use (defaults to PROTOCOL_TRY)

        Create a configuration object to be used in setting up a connection.

        """
        _nds2.parameters_swiginit(self, _nds2.new_parameters(*args))
    set = _swig_new_instance_method(_nds2.parameters_set)
    get = _swig_new_instance_method(_nds2.parameters_get)
    parameter_list = _swig_new_instance_method(_nds2.parameters_parameter_list)
    __swig_destroy__ = _nds2.delete_parameters

# Register parameters in _nds2:
_nds2.parameters_swigregister(parameters)

_fetch = _nds2._fetch
_find_channels = _nds2._find_channels
version = _nds2.version

import types
import sys

def _unicode_to_str(arg):
    arg_type = type(arg)
    if arg_type == types.UnicodeType:
        return str(arg)
    elif arg_type == types.ListType:
        return [x if type(x) != types.UnicodeType else str(x) for x in arg]
    elif arg_type == types.TupleType:
        return tuple([x if type(x) != types.UnicodeType else str(x) for x in arg])
    return arg

def _bytestr_to_unicode(arg):
        utype = type(u'')
        btype = type(b'')
        ltype = type([])
        ttype = type(())

        arg_type = type(arg)
        if arg_type == btype:
            return arg.decode()
        elif arg_type == ltype:
            return [x if type(x) != btype else x.decode() for x in arg]
        elif arg_type ==ttype:
            return tuple(x if type(x) != btype else x.decode() for x in arg)
        return arg

def _hack_for_python2_strings(args):
    """SWIG < 3.0  with Python 2 does not convert Python unicode strings
    to std::string or char *.  So force unicode strings to be byte strings"""
    if sys.version_info.major < 3 and len(args) > 0:
        args = tuple(map(_unicode_to_str, args))
    elif len(args) > 0:
        args = tuple(map(_bytestr_to_unicode, args))
    return args

ABORT_HANDLER = _nds2.ABORT_HANDLER

STATIC_HANDLER_ZERO = _nds2.STATIC_HANDLER_ZERO

STATIC_HANDLER_ONE = _nds2.STATIC_HANDLER_ONE

STATIC_HANDLER_NAN = _nds2.STATIC_HANDLER_NAN

STATIC_HANDLER_POS_INF = _nds2.STATIC_HANDLER_POS_INF

STATIC_HANDLER_NEG_INF = _nds2.STATIC_HANDLER_NEG_INF

SKIP_GAPS_IN_ITERATE = _nds2.SKIP_GAPS_IN_ITERATE


__version__ = version()

def __resolve_gap_handler(handler):
    mapping = {
               b'ABORT_HANDLER': ABORT_HANDLER,
               b'STATIC_HANDLER_ZERO': STATIC_HANDLER_ZERO,
               b'STATIC_HANDLER_ONE': STATIC_HANDLER_ONE,
               b'STATIC_HANDLER_NAN': STATIC_HANDLER_NAN,
               b'STATIC_HANDLER_POS_INF': STATIC_HANDLER_POS_INF,
               b'STATIC_HANDLER_NEG_INF': STATIC_HANDLER_NEG_INF,
               b'SKIP_GAPS_IN_ITERATE': SKIP_GAPS_IN_ITERATE,
               u'ABORT_HANDLER': ABORT_HANDLER,
               u'STATIC_HANDLER_ZERO': STATIC_HANDLER_ZERO,
               u'STATIC_HANDLER_ONE': STATIC_HANDLER_ONE,
               u'STATIC_HANDLER_NAN': STATIC_HANDLER_NAN,
               u'STATIC_HANDLER_POS_INF': STATIC_HANDLER_POS_INF,
               u'STATIC_HANDLER_NEG_INF': STATIC_HANDLER_NEG_INF,
               u'SKIP_GAPS_IN_ITERATE': SKIP_GAPS_IN_ITERATE,
               }
    return mapping.get(handler, handler)

def fetch(channels, gps_start, gps_stop, gap_handler=None, allow_data_on_tape=None, hostname=None, port=None, protocol=None, params=None):
    """Request offline data in a single chunk over [gps_start, gps_stop).

    Keyword arguments
    channels -- A list of channels to retrieve data from.
    gps_start -- A gps start time to retrieve data from.
    gps_stop -- The stop time in gps for the request.
    gap_handler -- The gap handling strategy to apply.
    hostname -- The host/server to connect to.
    port -- The port on the server to connect to.
    protocol -- The protocol version to connect with.
    params -- Optional parameters object allowing for the specification
    of gap handlers, servers, ...

    The gap_handler, allow_data_on_tape, hostname, port, and protocol fields
    are resolved as in the following way, with the first match being applied.
     * If the argument is not None it is used.
     * If the params argument is a `parameters` object then its values are used.
     * If the value is set in the environment it is used.
     * Otherwise a default value is used
       gap_handler = ABORT_HANDLER
       allow_data_on_tape = False
       hostname = localhost
       port = 31200
       protocol = PROTOCOL_TRY

    The behavior of the fetch function when a gap in the data is found is
    configurable via the gap_handler parameter.  The following gap_handlers
    are available:
     * ABORT_HANDLER - Abort the call with a data not found error.
     * STATIC_HANDLER_ZERO - Fill the gaps with 0 values.
     * STATIC_HANDLER_ONE - Fill the gaps with the value 1.
     * STATIC_HANDLER_NAN - Fill the gaps with NaN for real values and 0 for integer values.
     * STATIC_HANDLER_POS_INF - Fill the gaps with +Inf or the largest possible value.
     * STATIC_HANDLER_NEG_INF - Fill the gaps with -Inf or the smallest possible value.

    Returns a list of nds2.buffer objects, one per channel.

    Notes:
     * The SKIP_GAPS_IN_ITERATE is not a valid gap handler for fetch.  Currently
     it is treated the same as using the ABORT_HANDLER, but it may be change
     to raising an exception in the future.
    """
    if params is None:
        params = parameters()
    _gap_handler = __resolve_gap_handler(gap_handler)
    if _gap_handler is not None:
        if _gap_handler == ABORT_HANDLER or _gap_handler == SKIP_GAPS_IN_ITERATE:
            params.set('GAP_HANDLER', 'ABORT_HANDLER')
        elif _gap_handler == STATIC_HANDLER_ZERO:
            params.set('GAP_HANDLER', 'STATIC_HANDLER_ZERO')
        elif _gap_handler == STATIC_HANDLER_ONE:
            params.set('GAP_HANDLER', 'STATIC_HANDLER_ONE')
        elif _gap_handler == STATIC_HANDLER_NAN:
            params.set('GAP_HANDLER', 'STATIC_HANDLER_NAN')
        elif _gap_handler == STATIC_HANDLER_POS_INF:
            params.set('GAP_HANDLER', 'STATIC_HANDLER_POS_INF')
        elif _gap_handler == STATIC_HANDLER_NEG_INF:
            params.set('GAP_HANDLER', 'STATIC_HANDLER_NEG_INF')
        else:
            raise RuntimeError('Invalid gap handler selected')
    if not allow_data_on_tape is None:
        val = 'True'
        if not allow_data_on_tape:
            val = 'False'
        params.set('ALLOW_DATA_ON_TAPE', val)
    if not hostname is None:
        params.set('HOSTNAME', hostname)
    if not port is None:
        params.set('PORT', str(port))
    if not protocol is None:
        val = 'PROTOCOL_TRY'
        if protocol == connection.PROTOCOL_ONE:
            val = 'PROTOCOL_ONE'
        elif protocol == connection.PROTOCOL_TWO:
            val = 'PROTOCOL_TWO'
        params.set('PROTOCOL_VERSION', val)
    return _fetch(params, gps_start, gps_stop, channels)

def find_channels(channel_glob="*", channel_type_mask=channel.DEFAULT_CHANNEL_MASK, data_type_mask=channel.DEFAULT_DATA_MASK, min_sample_rate=channel.MIN_SAMPLE_RATE, max_sample_rate=channel.MAX_SAMPLE_RATE, timespan=None, hostname=None, port=None, protocol=None, params=None):
    """Retrieve a channel list.

    Keyword arguments
    channel_glob -- A bash link glob pattern used to match channel names.
    channel_type_mask -- A mask of channel types (CHANNEL_TYPE_RAW, CHANNEL_TYPE_ONLINE, ...) to limit the search to.
    data_type_mask -- A mask of data types (DATA_TYPE_INT32, DATA_TYPE_FLOAT32, ...)  to limit channels to
    min_sample_rate -- A minimum sample rate to search for.
    max_sample_rate -- A maximum sample rate to search for.
    timespan -- Optional time span to limit available channel search to.  This may be an nds2.epoch or a tuple of [start, stop) times.
    hostname -- The host/server to connect to.
    port -- The port on the server to connect to.
    protocol -- The protocol version to connect with.
    params -- Optional parameters allowing for the specification of a specific server to query.

    The hostname, port, and protocol are resolved as in the
    following way, with the first match being applied.
     * If the argument is not None it is used.
     * If the params argument is a `parameters` object its values are used.
     * If the value is set in the environment it is used.
     * Otherwise a default value is used
       hostname = localhost
       port = 31200
       protocol = PROTOCOL_TRY

    Returns a list of nds2.channel objects that match the given parameters.
    """
    dummy_epoch = epoch()
    timespan_type = type(timespan)

    if params is None:
        params = parameters()
    if timespan is None:
        timespan = epoch("", 0, buffer.GPS_INF)
    elif not timespan_type == type(dummy_epoch):
        timespan = epoch("", *timespan)
    if not hostname is None:
        params.set('HOSTNAME', hostname)
    if not port is None:
        params.set('PORT', str(port))
    if not protocol is None:
        val = 'PROTOCOL_TRY'
        if protocol == connection.PROTOCOL_ONE:
            val = 'PROTOCOL_ONE'
        elif protocol == connection.PROTOCOL_TWO:
            val = 'PROTOCOL_TWO'
        params.set('PROTOCOL_VERSION', val)
    return _find_channels(params, channel_glob, channel_type_mask, data_type_mask, min_sample_rate, max_sample_rate, timespan)

def iterate(channels, gps_start = 0, gps_stop = 0, stride = 0, gap_handler=None, allow_data_on_tape=None, hostname=None, port=None, protocol=None, params = None):
    """Stream nds data for a given set of channels.

    Keyword arguments
    channels -- A list of channels to stream data from.
    gps_start -- A start time, defaults to 0
    gps_stop -- stop time, defaults to 0
    stride -- Requested stride/buffer size to be returned.  Defaults to 0.
    params -- Optional parameters object allowing for the specification
    of gap handlers, servers, ...

    The gap_handler, allow_data_on_tape, hostname, port, and protocol fields
    are resolved as in the following way, with the first match being applied.
     * If the argument is not None it is used.
     * If the params argument is a `parameters` object its values are used.
     * If the value is set in the environment it is used.
     * Otherwise a default value is used
       gap_handler = ABORT_HANDLER
       allow_data_on_tape = False
       hostname = localhost
       port = 31200
       protocol = PROTOCOL_TRY

    The behavior of the iterate function when a gap in the data is found is
    configurable via the gap_handler parameter.  The following gap_handlers
    are available:
     * ABORT_HANDLER - Abort the call with a data not found error.
     * STATIC_HANDLER_ZERO - Fill the gaps with 0 values.
     * STATIC_HANDLER_ONE - Fill the gaps with the value 1.
     * STATIC_HANDLER_NAN - Fill the gaps with NaN for real values and 0 for integer values.
     * STATIC_HANDLER_POS_INF - Fill the gaps with +Inf or the largest possible value.
     * STATIC_HANDLER_NEG_INF - Fill the gaps with -Inf or the smallest possible value.
     * SKIP_GAPS_IN_ITERATE - Skip over gaps, only return segments of valid data.

    Notes:
     * To request unbounded live data, set gps_start to 0, gps_stop to 0, stride to 0.
     * To request bounded live data, set gps_start to 0, gsp_stop to the duration, stride to 0.
     * To request offline/archived data specify both gps_start and gps_stop.
    Stride is used to influence the block size.  It is a requested size value.  There are two
    constants that help, channel.AUTO_STRIDE asks the nds server to autoconfigure the stride size,
    channel.FAST_STRIDE requests data be sent at 16Hz.  FAST_STRIDE is nds1 only and degrades to
    AUTO_STRIDE if the server cannot support FAST_STRIDE.
     * If gap_handler is set to SKIP_GAPS_IN_ITERATE and channels that do not have identical gaps
    are selected a data not found exception will be raised.

    """
    from contextlib import closing
    if params is None:
        params = parameters()
    _gap_handler = __resolve_gap_handler(gap_handler)
    if _gap_handler is not None:
        if _gap_handler == ABORT_HANDLER:
            params.set('GAP_HANDLER', 'ABORT_HANDLER')
            params.set('ITERATE_USE_GAP_HANDLERS', 'True')
        elif _gap_handler == STATIC_HANDLER_ZERO:
            params.set('GAP_HANDLER', 'STATIC_HANDLER_ZERO')
            params.set('ITERATE_USE_GAP_HANDLERS', 'True')
        elif _gap_handler == STATIC_HANDLER_ONE:
            params.set('GAP_HANDLER', 'STATIC_HANDLER_ONE')
            params.set('ITERATE_USE_GAP_HANDLERS', 'True')
        elif _gap_handler == STATIC_HANDLER_NAN:
            params.set('GAP_HANDLER', 'STATIC_HANDLER_NAN')
            params.set('ITERATE_USE_GAP_HANDLERS', 'True')
        elif _gap_handler == STATIC_HANDLER_POS_INF:
            params.set('GAP_HANDLER', 'STATIC_HANDLER_POS_INF')
            params.set('ITERATE_USE_GAP_HANDLERS', 'True')
        elif _gap_handler == STATIC_HANDLER_NEG_INF:
            params.set('GAP_HANDLER', 'STATIC_HANDLER_NEG_INF')
            params.set('ITERATE_USE_GAP_HANDLERS', 'True')
        elif _gap_handler == SKIP_GAPS_IN_ITERATE:
            params.set('ITERATE_USE_GAP_HANDLERS', 'False')
        else:
            raise RuntimeError('Invalid gap handler selected')
    if not allow_data_on_tape is None:
        val = 'True'
        if not allow_data_on_tape:
            val = 'False'
        params.set('ALLOW_DATA_ON_TAPE', val)
    if not hostname is None:
        params.set('HOSTNAME', hostname)
    if not port is None:
        params.set('PORT', str(port))
    if not protocol is None:
        val = 'PROTOCOL_TRY'
        if protocol == connection.PROTOCOL_ONE:
            val = 'PROTOCOL_ONE'
        elif protocol == connection.PROTOCOL_TWO:
            val = 'PROTOCOL_TWO'
        params.set('PROTOCOL_VERSION', val)
    with closing(connection(params)) as conn:
        for bufs in conn.iterate(gps_start, gps_stop, stride, channels):
            yield bufs





