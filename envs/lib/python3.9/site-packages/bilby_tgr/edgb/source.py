import lalsimulation
from bilby.gw.source import _base_lal_cbc_fd_waveform
from lal import CreateDict
import numpy as np

M_sec = 4.925490947641266978197229498498379006e-6


def edgb_waveform_generator(
    frequency_array, mass_1, mass_2, luminosity_distance,
    chi_1, chi_2, theta_jn, phase, alpha,
    **kwargs):
    waveform_kwargs = dict(
        waveform_approximant='IMRPhenomXAS', reference_frequency=20.0,
        minimum_frequency=20.0, maximum_frequency=1024.0,
        catch_waveform_errors=False, pn_spin_order=-1, pn_tidal_order=-1,
        pn_phase_order=-1, pn_amplitude_order=0)

    tilt1 = 0
    tilt2 = 0
    if chi_1<0:
        tilt1 = np.pi
    if chi_2<0:
        tilt2 = np.pi
    GR_waveform = _base_lal_cbc_fd_waveform(
        frequency_array=frequency_array, mass_1=mass_1, mass_2=mass_2,
        luminosity_distance=luminosity_distance, theta_jn=theta_jn, phase=phase,
        a_1=np.abs(chi_1), a_2=np.abs(chi_2), tilt_1=tilt1, tilt_2 = tilt2, **waveform_kwargs)
        #a_1=a_1, a_2=a_2, tilt_1=tilt_1, tilt_2=tilt_2, phi_12=phi_12,
        #phi_jl=phi_jl, **waveform_kwargs)

    edgb_waveform = get_phase(GR_waveform, frequency_array, mass_1, mass_2, chi_1, chi_2, alpha, True)
    return edgb_waveform


def edgb_XPHM_generator(
    frequency_array, mass_1, mass_2, luminosity_distance,
    a_1, tilt_1, phi_12, a_2, tilt_2, phi_jl, theta_jn, phase, alpha,
    **kwargs):
    print("XAS")
    waveform_kwargs = dict(
        waveform_approximant='IMRPhenomXAS', reference_frequency=20.0,
        minimum_frequency=20.0, maximum_frequency=1024.0,
        catch_waveform_errors=False, pn_spin_order=-1, pn_tidal_order=-1,
        pn_phase_order=-1, pn_amplitude_order=0)

    GR_waveform = _base_lal_cbc_fd_waveform(
        frequency_array=frequency_array, mass_1=mass_1, mass_2=mass_2,
        luminosity_distance=luminosity_distance, theta_jn=theta_jn, phase=phase,
        a_1=a_1, a_2=a_2, tilt_1=tilt_1, tilt_2=tilt_2, phi_12=phi_12,
        phi_jl=phi_jl, **waveform_kwargs)

    edgb_waveform = zhenwei_phase(GR_waveform, frequency_array, mass_1, mass_2, a_1, a_2, alpha, False)
    return edgb_waveform

def get_phase(waveform_hp, frequency_array, mass_1, mass_2,
    chi_1, chi_2, alpha, all_pn):
    edgb_waveform = {}
    edgb_waveform['plus'] = waveform_hp['plus']
    edgb_waveform['cross'] = waveform_hp['cross']
    Mtot = mass_1 + mass_2
    transform_frequency = np.logical_and(frequency_array>=20.0, frequency_array<=1024.0)
    relative_velocity = np.power(frequency_array[transform_frequency] * np.pi * Mtot * M_sec, 1/3.)

    s1EdGB = 2*(np.sqrt(1-chi_1*chi_1) - 1 + chi_1*chi_1) / chi_1/ chi_1
    s2EdGB = 2*(np.sqrt(1-chi_2*chi_2) - 1 + chi_2*chi_2) / chi_2/ chi_2

    eta = mass_1*mass_2 / (Mtot**2)
    
    mEdGB = np.square(mass_1*mass_1*s2EdGB-mass_2*mass_2*s1EdGB)
    mAdd = mass_1*mass_1*s2EdGB + mass_2*mass_2*s1EdGB
    divisor = (eta**5) * (Mtot**4)

    coeff_m1 = -5*np.pi/448 * mEdGB/divisor
    sum_terms = coeff_m1 * np.power(relative_velocity, -7)
    if all_pn:
        coeff_0 = -5*np.pi/43008 * (659+728*eta)*mEdGB/divisor - 5*np.pi/16*s1EdGB*s2EdGB/(eta**3)
        coeff_05 = 75*np.pi*np.pi/448 * mEdGB / divisor
        coeff_1 = -5*np.pi/48384 * mAdd * mAdd * (535 + 924 * eta)/divisor - 25*np.pi/576 * mEdGB / divisor * (12497995/1016064 - 11 * (mass_1 - mass_2) * mAdd / 2 / Mtot / (mass_1*mass_1*s2EdGB-mass_2*mass_2*s1EdGB) + 15407*eta/1440 + 165*eta*eta/16)
        coeff_15 = np.pi*np.pi/2*mEdGB/divisor - 6 * np.pi * np.pi *s1EdGB * s2EdGB/(eta**3)
        coeff_2 = 5*np.pi/32514048/divisor*(((mass_1**5)*s2EdGB*s2EdGB+(mass_2**5)*s1EdGB*s1EdGB)*(-4341025+65553264*eta-684432*eta*eta) + eta * Mtot * Mtot * ((mass_1**3)*s2EdGB*s2EdGB+(mass_2**3)*s1EdGB*s1EdGB) * (20044511 + 65553264*eta - 684432*eta*eta) + 54*eta*eta*(Mtot**5)*s2EdGB*s1EdGB*(12952549-19310256*eta-366128*eta*eta))
        sum_terms += coeff_0 * np.power(relative_velocity, -5) + coeff_05 * np.power(relative_velocity, -4) + coeff_1 * np.power(relative_velocity, -3) + coeff_15 * np.power(relative_velocity, -2) + coeff_2 * np.power(relative_velocity, -1)


    dphi = (alpha**4) * sum_terms
    dphi = dphi - dphi[0]
    edgb_waveform['plus'][transform_frequency]  = waveform_hp['plus'][transform_frequency] * np.exp(1j * dphi)
    edgb_waveform['cross'][transform_frequency] = waveform_hp['cross'][transform_frequency]* np.exp(1j * dphi)
    return edgb_waveform


def zhenwei_phase(waveform_hp, frequency_array, m1, m2,
    chi_1, chi_2, alpha, all_pn):
    print(alpha)
    edgb_waveform = {}
    edgb_waveform['plus'] = waveform_hp['plus']
    edgb_waveform['cross'] = waveform_hp['cross']
    Mtot = m1 + m2
    transform_frequency = np.logical_and(frequency_array>=20.0, frequency_array<=1024.0)
    relative_velocity = np.power(frequency_array[transform_frequency] * np.pi * Mtot * M_sec, 1/3.)

    s1EdGB = 2*(np.sqrt(1-chi_1*chi_1) - 1 + chi_1*chi_1) / (chi_1**2)
    #s2EdGB = 2*(np.sqrt(1-chi_2*chi_2) - 1 + chi_2*chi_2) / chi_2/ chi_2
    s2EdGB = 0
    eta = m1*m2 / (Mtot**2)
    coef = np.pi * (alpha**4) / (eta**5) / (Mtot**4)
    phi_EdGB_coef = -5.0/448 * coef * ((m1*m1*s2EdGB - m2*m2*s1EdGB)**2)
    dphi = phi_EdGB_coef * np.power(relative_velocity, -7)
    if all_pn:
        print("all PN")
        phi_EdGB_coef_0PN = -5.0/43008 * coef * ((728*eta+659)*(m1**4)*s2EdGB*s2EdGB - 2.0*(728*eta+2003)*((m1*m2)**2)*s1EdGB*s2EdGB + (728*eta+659)*(m2**4)*s1EdGB*s1EdGB)
        phi_EdGB_coef_1PN = -5.0/48384 * coef * (535+924*eta)*((m1*m1*s2EdGB + m2*m2*s1EdGB)**2) - 25.0/576 * coef * ((m1*m1*s2EdGB - m2*m2*s1EdGB)**2) * (12497995.0/1016064 - 5.5*(m1-m2)*(m2*m2*s1EdGB+m1*m1*s2EdGB) /(m1+m2)/(m1*m1*s2EdGB - m2*m2*s1EdGB) + 15407.0/1440*eta + 165.0/16*eta*eta)

        phi_EdGB_coef_05PN = 75.0*np.pi/448 * coef * ((m1*m1*s2EdGB - m2*m2*s1EdGB)**2)
        phi_EdGB_coef_15PN = 0.5*np.pi* coef * ((m2**4)*s1EdGB*s1EdGB - 10.0*m1*m1*m2*m2*s1EdGB*s2EdGB + (m1**4)*s2EdGB*s2EdGB)
        phi_EdGB_coef_2PN = 5.0/32514048 * coef/(m1+m2) * (((m2**5)*s1EdGB*s1EdGB + (m1**5)*s2EdGB*s2EdGB)*(-4341025.0 + 65553264.0*eta - 684432.0*eta*eta) + m1*m2*((m2**3)*s1EdGB*s1EdGB + (m1**3)*s2EdGB*s2EdGB)*(20044511.0 + 65553264.0*eta - 684432.0*eta*eta) - 2.0*m1*m1*m2*m2*s1EdGB*s2EdGB*(m1+m2)*(-33856691.0 + 742247856.0*eta + 149961168.0*eta*eta))
        dphi += phi_EdGB_coef_0PN * np.power(relative_velocity, -5) + phi_EdGB_coef_05PN * np.power(relative_velocity, -4) + phi_EdGB_coef_1PN * np.power(relative_velocity, -3) + phi_EdGB_coef_15PN * np.power(relative_velocity, -2) + phi_EdGB_coef_2PN * np.power(relative_velocity, -1)

    dphi = dphi - dphi[0]

    edgb_waveform['plus'][transform_frequency]  = waveform_hp['plus'][transform_frequency] * np.exp(1j * dphi)
    edgb_waveform['cross'][transform_frequency] = waveform_hp['cross'][transform_frequency]* np.exp(1j * dphi)
    return edgb_waveform
    
