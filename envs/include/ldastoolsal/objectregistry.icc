/* -*- mode: C++; c-basic-offset: 4 -*- */
#ifndef GENERAL__OBJECT_REGISTRY_ICC
#define GENERAL__OBJECT_REGISTRY_ICC

#include <algorithm>
#include <sstream>

#include "ldastoolsal/ErrorLog.hh"

//-----------------------------------------------------------------------
/// This creates a registry with no objects stored.
//-----------------------------------------------------------------------
template< class T >
ObjectRegistry< T >::
ObjectRegistry( )
{
}


//-----------------------------------------------------------------------
/// Deletes all of the registered objects.
//-----------------------------------------------------------------------
template< class T >
ObjectRegistry< T >::
~ObjectRegistry( )
{
    reset( );
}


//-----------------------------------------------------------------------
/// Deletes all registered objects and removes them from the registry.
//-----------------------------------------------------------------------
template< class T >
void ObjectRegistry< T >::
reset( )
{ 
    LDASTools::AL::ReadWriteLock m( m_lock, LDASTools::AL::ReadWriteLock::WRITE,
				    __FILE__, __LINE__ );
    if ( LDASTools::AL::StdErrLog.IsOpen( ) )
    {
	std::ostringstream	msg;

	msg << "ObjectRegistry< T >::reset( )";
	LDASTools::AL::StdErrLog( LDASTools::AL::ErrorLog::DEBUG, __FILE__, __LINE__,
				  msg.str( ) );
    }

    /// iterate through the registry deleting the objects
    for( iterator iter = begin( ); iter != end( ); iter++ )
    {
        delete iter->first;
    }

    /// now erase the registry
    mData.erase( begin( ), end( ) );
}


//-----------------------------------------------------------------------
/// Registers an object with the registry.
//  This method inserts a pointer to an object into the registry.
///
/// \param o
///     A pointer to the object to register.  If the pointer is null,
///     then nothing happens.
///
//-----------------------------------------------------------------------
template< class T >
void ObjectRegistry< T >::
registerObject( T* o )
{
    LDASTools::AL::ReadWriteLock m( m_lock, LDASTools::AL::ReadWriteLock::WRITE,
				    __FILE__, __LINE__ );
    if ( o != 0 )
    {
	if ( LDASTools::AL::StdErrLog.IsOpen( ) )
	{
	    std::ostringstream	msg;

	    msg << "ObjectRegistry< T >::registerObject( " << (void*)o << ")";
	    LDASTools::AL::StdErrLog( LDASTools::AL::ErrorLog::DEBUG, __FILE__, __LINE__,
				      msg.str( ) );
	}
        mData[ o ];
    }
}


//-----------------------------------------------------------------------
/// This method removes an object from the registry.
/// If successfully removed, then the object is also deleted
/// so as to reclaim the memory accociated with the object.
///
/// \param o
///     A pointer to the object to destruct and remove from the
///     registry.
///
/// \return
///     True if the object was found and removed; false otherwise.
//-----------------------------------------------------------------------
template< class T >
bool ObjectRegistry< T >::
destructObject( T* o )
{
    LDASTools::AL::ReadWriteLock m( m_lock, LDASTools::AL::ReadWriteLock::WRITE,
				    __FILE__, __LINE__ );

    if ( LDASTools::AL::StdErrLog.IsOpen( ) )
    {
	std::ostringstream	msg;

	msg << "ObjectRegistry< T >::destructObject( " << (void*)o << ")";
	LDASTools::AL::StdErrLog( LDASTools::AL::ErrorLog::DEBUG, __FILE__, __LINE__,
				  msg.str( ) );
    }

    iterator iter = mData.find( o );
    if ( iter != end( ) )
    {
	if ( iter->second.m_reference_count )
	{
	    if ( iter->second.m_remove_object )
	    {
		// Object is no longer in list
		return false;
	    }
	    iter->second.m_delete_object = true;
	    iter->second.m_remove_object = true;
	}
	else
	{
	    T* ptr = iter->first;
	    mData.erase( iter );
	    m.Release( __FILE__, __LINE__ );
	    delete ptr;
	}
        return true;
    }
    else
    {
        return false;
    }
}


//-----------------------------------------------------------------------
/// Removes an object from the server.  The object is not destructed.
///
/// \param o
///     A pointer to the object to remove from the registry.
///
/// \return
///     True if the object was found and removed; false otherwise.
///
//-----------------------------------------------------------------------
template< class T >
bool ObjectRegistry< T >::
removeObject( T* o )
{
    LDASTools::AL::ReadWriteLock m( m_lock, LDASTools::AL::ReadWriteLock::WRITE,
				    __FILE__, __LINE__ );
    if ( LDASTools::AL::StdErrLog.IsOpen( ) )
    {
	std::ostringstream	msg;

	msg << "ObjectRegistry< T >::removeObject( " << (void*)o << ")";
	LDASTools::AL::StdErrLog( LDASTools::AL::ErrorLog::DEBUG, __FILE__, __LINE__,
				  msg.str( ) );
    }

    iterator iter = mData.find( o );

    if ( iter != end( ) )
    {
	if ( iter->second.m_reference_count )
	{
	    if ( iter->second.m_remove_object )
	    {
		// Object has already been requested to be removed.
		return false;
	    }
	    iter->second.m_remove_object = true;
	}
	else
	{
	    if ( iter->second.m_delete_object )
	    {
		delete iter->first;
	    }
	    mData.erase( iter );
	}
	return true;
    }
    else
    {
        return false;
    }
}


//-----------------------------------------------------------------------
/// Tests if an object is in the list of registered objects.
///
/// \param o
///     This object is searched through the container of
///     registered objects.
///
/// \return
///     True if the object is within the registry; false otherwise.
///
/// \note
///     Objects that are in the registry but flagged as deleted are
///     considered unregistered.
//-----------------------------------------------------------------------
template< class T >
bool ObjectRegistry< T >::
isRegistered( const T* o ) const
{
    if ( LDASTools::AL::StdErrLog.IsOpen( ) )
    {
	std::ostringstream	msg;

	msg << "ObjectRegistry< T >::isRegistered( " << (void*)o << ")";
	LDASTools::AL::StdErrLog( LDASTools::AL::ErrorLog::DEBUG, __FILE__, __LINE__,
				  msg.str( ) );
    }

    LDASTools::AL::ReadWriteLock m( m_lock, LDASTools::AL::ReadWriteLock::READ,
				    __FILE__, __LINE__ );

    const_iterator i( mData.find( const_cast< T* >( o ) ) );

    if ( ( i == end( ) )
	 || ( i->second.m_remove_object ) )
    {
	return false;
    }
    return true;
}


//-----------------------------------------------------------------------
/// Returns the number of registered objects in the registry.
///
/// \return
///     The number of registered objects.
///
/// \todo
///     Need to investigate if objects flagged for deletion or removal
///     should be excluded from the count.
//-----------------------------------------------------------------------
template< class T >
size_t ObjectRegistry< T >::
size( ) const
{
    LDASTools::AL::ReadWriteLock m( m_lock, LDASTools::AL::ReadWriteLock::READ,
				    __FILE__, __LINE__ );
    return mData.size( );
}

//-----------------------------------------------------------------------
/// Perform an action on each registered object not flagged for
/// removal.
///
/// \param Function
///     Function to perform on each object in the registry.
///
/// \return
///     Result of the operation done on the last element
///     in the registry.
//-----------------------------------------------------------------------
template< class T >
template< class Op > Op ObjectRegistry< T >::
for_each( Op Function ) const
{
    LDASTools::AL::ReadWriteLock m( m_lock, LDASTools::AL::ReadWriteLock::READ,
				    __FILE__, __LINE__ );

    for ( const_iterator
	      cur = begin( ),
	      last = end( );
	  cur != last;
	  ++cur )
    {
	if ( cur->second.m_remove_object == false )
	{
	    Function( cur->first );
	}
    }

    return Function;
}


//-----------------------------------------------------------------------
/// If the requested object is being managed by the registry,
/// then flag it as being in use.
///
/// \param Object
///     The object to be flagged as being in use.
//-----------------------------------------------------------------------
template< class T >
void ObjectRegistry< T >::
lock( T* Object )
{
    LDASTools::AL::ReadWriteLock m( m_lock, LDASTools::AL::ReadWriteLock::WRITE,
				    __FILE__, __LINE__ );

    iterator i( mData.find( Object ) );

    if ( i == end( )
	 || ( i->second.m_remove_object ) )
    {
	throw std::range_error( "Object not in registry" );
    }
    ++( i->second.m_reference_count );
}

//-----------------------------------------------------------------------
/// If the requested object is being managed by the registry,
/// then unset the flag so as to indicate the object is no longer in use.
/// After unsetting the flag, check to see if the object should be
/// deleted or removed from the registry and perform the appropriate
/// actions.
//-----------------------------------------------------------------------
template< class T >
void ObjectRegistry< T >::
unlock( T* Object )
{
    LDASTools::AL::ReadWriteLock m( m_lock, LDASTools::AL::ReadWriteLock::WRITE,
				    __FILE__, __LINE__ );

    iterator i( mData.find( Object ) );

    if ( i != end( ) )
    {
	if ( --( i->second.m_reference_count ) == 0 )
	{
	    if ( i->second.m_delete_object )
	    {
		delete i->first;
	    }
	    if ( i->second.m_remove_object )
	    {
		mData.erase( i );
	    }
	}
    }
}

#endif // GENERAL__OBJECT_REGISTRY_ICC
